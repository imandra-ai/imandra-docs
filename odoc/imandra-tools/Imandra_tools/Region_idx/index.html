<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Region_idx (imandra-tools.Imandra_tools.Region_idx)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">imandra-tools</a> &#x00BB; <a href="../index.html">Imandra_tools</a> &#x00BB; Region_idx</nav><h1>Module <code>Imandra_tools.Region_idx</code></h1></header><dl><dt class="spec module-type" id="module-type-Args"><a href="#module-type-Args" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-Args/index.html">Args</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Argument types of the decomposed function, as a tuple *</p></dd></dl><dl><dt class="spec value" id="val-synthesize"><a href="#val-synthesize" class="anchor"></a><code><span class="keyword">val</span> synthesize : <span>?&#8288;compound:bool</span> <span>&#45;&gt;</span> <span>Imandra_surface.Modular_region.t list</span> <span>&#45;&gt;</span> <span><span>(int * Imandra_surface.Modular_region.t)</span> list</span> * string</code></dt><dd><p>Takes a list of regions and returns an int -&gt; region index, and code to map arguments to the decomposed function to the index of the region the arguments belong to If the arguments belong to no region in the region list, returns -1 *</p></dd></dl><dl><dt class="spec value" id="val-indexer_f_for"><a href="#val-indexer_f_for" class="anchor"></a><code><span class="keyword">val</span> indexer_f_for : <span>?&#8288;assuming:string</span> <span>&#45;&gt;</span> <span>Imandra_surface.Modular_region.t list</span> <span>&#45;&gt;</span> <span><span>(int * Imandra_surface.Modular_region.t)</span> list</span> * string</code></dt><dd><p>Like <code>synthesize</code>, but insted of returning code it returns a function name for the indexer *</p></dd></dl><dl><dt class="spec value" id="val-indexer_for"><a href="#val-indexer_for" class="anchor"></a><code><span class="keyword">val</span> indexer_for : <span>(<span class="keyword">module</span> <a href="module-type-Args/index.html">Args</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-Args/index.html#type-args">args</a> = <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span>?&#8288;assuming:string</span> <span>&#45;&gt;</span> <span>Imandra_surface.Modular_region.t list</span> <span>&#45;&gt;</span> <span><span>(int * Imandra_surface.Modular_region.t)</span> list</span> * <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int)</span></code></dt><dd><p>Same as <code>indexer_f_for</code>, but returns a first class function instead of a function name, the arguments to the indexer are passed as a tuple, whose type must match the args type in the first class module argument. If the arguments belong to no region in the region list, throws <code>Not_found</code> *</p></dd></dl></div></body></html>