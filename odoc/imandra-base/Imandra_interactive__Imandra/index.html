<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Imandra_interactive__Imandra (imandra-base.Imandra_interactive__Imandra)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">imandra-base</a> &#x00BB; Imandra_interactive__Imandra</nav><h1>Module <code>Imandra_interactive__Imandra</code></h1><h3 id="initialization"><a href="#initialization" class="anchor"></a>Initialization</h3><nav class="toc"><ul><li><a href="#processing-statements">Processing Statements</a></li><li><a href="#extension-points">Extension Points</a></li><li><a href="#main-loop">Main Loop</a></li><li><a href="#render-documents">Render Documents</a><ul><li><a href="#string--&gt;-term-and-expr-conversion">String -&gt; Term and Expr conversion</a></li></ul></li><li><a href="#module-system">Module System</a></li></ul></nav></header><dl><dt class="spec value" id="val-set_lockdown"><a href="#val-set_lockdown" class="anchor"></a><code><span class="keyword">val</span> set_lockdown : int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>set_lockdown uid</code> enables lockdown mode. It will restrict what functions are in scope, and will <code>Unix.setuid</code> to the given user ID. <b>NOTE</b>: must be called before <a href="index.html#val-do_init"><code>do_init</code></a> or <code>loop</code></p></dd></dl><dl><dt class="spec value" id="val-do_init"><a href="#val-do_init" class="anchor"></a><code><span class="keyword">val</span> do_init : <span>?&#8288;linenoise:bool</span> <span>&#45;&gt;</span> <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Initialize the toplevel environment. Can be safely called several times but will only do something on the first call</p></dd></dl><section><header><h3 id="processing-statements"><a href="#processing-statements" class="anchor"></a>Processing Statements</h3></header><dl><dt class="spec value" id="val-on_eval_string"><a href="#val-on_eval_string" class="anchor"></a><code><span class="keyword">val</span> on_eval_string : <span>Imandra_surface.Code_fragment.t Imandra_util.Observable.t</span></code></dt><dd><p>Event triggered on every source code string evaluated. This may <b>NOT</b> include calls to <code>#use</code> and others.</p></dd></dl><dl><dt class="spec value" id="val-on_eval_top_phrase"><a href="#val-on_eval_top_phrase" class="anchor"></a><code><span class="keyword">val</span> on_eval_top_phrase : <span>Parsetree.toplevel_phrase Imandra_util.Observable.t</span></code></dt><dd><p>Event triggered for every top phrase evaluated, including program mode ones.</p></dd></dl><dl><dt class="spec value" id="val-use_iml"><a href="#val-use_iml" class="anchor"></a><code><span class="keyword">val</span> use_iml : <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> <span>?&#8288;batch:bool</span> <span>&#45;&gt;</span> <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>use_iml file</code> loads the file in imandra, as <code>#use &quot;file&quot;</code> would do.</p></dd></dl><dl><dt class="spec value" id="val-eval_string"><a href="#val-eval_string" class="anchor"></a><code><span class="keyword">val</span> eval_string : <span>?&#8288;interrupted:Imandra_util.Switch.t</span> <span>&#45;&gt;</span> <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> <span>?&#8288;batch:bool</span> <span>&#45;&gt;</span> <span>?&#8288;out:Stdlib.Format.formatter</span> <span>&#45;&gt;</span> <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <span>?&#8288;loc:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>Imandra_surface.Top_result.t list</span></code></dt><dd><p><code>eval_string &quot;1+1;;&quot;</code> will evaluate the given string as an Imandra statement.</p><dl><dt>parameter batch</dt><dd><p>if true, process all events in the string at once</p></dd></dl><dl><dt>returns</dt><dd><p>a list of toplevel results, to be printed somehow Precondition: <code>do_init ()</code> was called.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : <span>?&#8288;interrupted:Imandra_util.Switch.t</span> <span>&#45;&gt;</span> <span>?&#8288;out:Stdlib.Format.formatter</span> <span>&#45;&gt;</span> <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <span>?&#8288;loc:Imandra_util.Iloc.t</span> <span>&#45;&gt;</span> Parsetree.toplevel_phrase <span>&#45;&gt;</span> <span>Imandra_surface.Top_result.t list</span></code></dt><dd><p>evaluate the given toplevel phrase.</p><dl><dt>returns</dt><dd><p>a list of toplevel results, to be printed somehow. Precondition: <code>do_init ()</code> was called.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-eval_string_result"><a href="#val-eval_string_result" class="anchor"></a><code><span class="keyword">val</span> eval_string_result : <span>?&#8288;batch:bool</span> <span>&#45;&gt;</span> <span>?&#8288;out:Stdlib.Format.formatter</span> <span>&#45;&gt;</span> <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <span>?&#8288;loc:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span>Imandra_surface.Top_result.t list</span>, exn)</span> Stdlib.result</span></code></dt><dd><p><code>eval_string_result &quot;1+1;;&quot;</code> will evaluate the given string as an Imandra statement.</p><dl><dt>parameter batch</dt><dd><p>if true, process all events in the string at once</p></dd></dl><dl><dt>returns</dt><dd><p><code>Ok l</code> where <code>l</code> is a list of toplevel results, to be printed somehow, if evaluation succeeded; <code>Error e</code> if evaluation failed with exception <code>e</code>. Precondition: <code>do_init ()</code> was called.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-eval_string_iter"><a href="#val-eval_string_iter" class="anchor"></a><code><span class="keyword">val</span> eval_string_iter : <span>?&#8288;out:Stdlib.Format.formatter</span> <span>&#45;&gt;</span> <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <span>?&#8288;interrupted:Imandra_util.Switch.t</span> <span>&#45;&gt;</span> <span>filename:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>(<span>(<span>Imandra_util.Iloc.t list</span> * Imandra_util.Console.Capture.t * <span><span>(<span>Imandra_surface.Event.t list</span>, string)</span> Stdlib.result</span>)</span> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>eval_string_iter code f</code> evaluates <code>code</code> into a list of events, processes these events one by one, calling <code>f</code> on the result of each event. Each result is: <code>(locations, console, res)</code> Precondition: <code>do_init ()</code> was called.</p></dd></dl><dl><dt class="spec type" id="type-validate_result_async"><a href="#type-validate_result_async" class="anchor"></a><code><span class="keyword">type</span> validate_result_async</code></dt><dd><p>Results of validating some events using logical reasoning, termination analysis, theorem proving, etc.</p></dd></dl><dl><dt class="spec value" id="val-process_events"><a href="#val-process_events" class="anchor"></a><code><span class="keyword">val</span> process_events : <span>?&#8288;console_cap:bool</span> <span>&#45;&gt;</span> <span>?&#8288;interrupted:Imandra_util.Switch.t</span> <span>&#45;&gt;</span> <span>?&#8288;batch:bool</span> <span>&#45;&gt;</span> <span>Imandra_surface.Event.t list</span> <span>&#45;&gt;</span> <span><a href="index.html#type-validate_result_async">validate_result_async</a> list</span></code></dt><dd><p>Process events so as to validate them on the reasoning side. Returns a list of future results.</p><dl><dt>parameter batch</dt><dd><p>if true, validate all events at once</p></dd></dl><dl><dt>parameter console_cap</dt><dd><p>if true, capture console output on the reasoning side and into the validate result.</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-wait_block_for_validate_res_async"><a href="#val-wait_block_for_validate_res_async" class="anchor"></a><code><span class="keyword">val</span> wait_block_for_validate_res_async : <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-validate_result_async">validate_result_async</a> <span>&#45;&gt;</span> <span><span>(<span>Imandra_surface.Event.op list</span>, exn)</span> Stdlib.result</span> * Imandra_util.Console.Capture.t</code></dt><dd><p>Wait for a validation result</p></dd></dl><dl><dt class="spec value" id="val-wait_for_validate_res_async"><a href="#val-wait_for_validate_res_async" class="anchor"></a><code><span class="keyword">val</span> wait_for_validate_res_async : <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <a href="index.html#type-validate_result_async">validate_result_async</a> <span>&#45;&gt;</span> <span><span>(<span><span>(<span>Imandra_surface.Event.op list</span>, exn)</span> Stdlib.result</span> * Imandra_util.Console.Capture.t)</span> <a href="../Imandra_thread_util/Fut/index.html#type-t">Imandra_thread_util.Fut.t</a></span></code></dt><dt class="spec value" id="val-eval_string_returning_string"><a href="#val-eval_string_returning_string" class="anchor"></a><code><span class="keyword">val</span> eval_string_returning_string : string <span>&#45;&gt;</span> string</code></dt><dd><p><code>eval_string_returning_string s</code> evaluates <code>s</code>, which must be a code fragment returning a string, and returns the resulting string value.</p><p>Example:</p><pre><code class="ml"># Imandra.eval_string_returning_string {| &quot;hello &quot; ^ &quot;world&quot; |};;
- : string = &quot;hello world&quot;

# Imandra.eval_string_returning_string {| Printf.sprintf &quot;%B&quot; true |};;
- : string = &quot;true&quot;</code></pre></dd></dl><dl><dt class="spec value" id="val-parse_file"><a href="#val-parse_file" class="anchor"></a><code><span class="keyword">val</span> parse_file : <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span><span>(<span>Parsetree.toplevel_phrase list</span>, exn)</span> Stdlib.result</span></code></dt><dd><p>Parse given file</p></dd></dl><dl><dt class="spec value" id="val-parse_string"><a href="#val-parse_string" class="anchor"></a><code><span class="keyword">val</span> parse_string : <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> <span>?&#8288;filename:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> Imandra_util.Iloc.t * <span><span>(<span>Parsetree.toplevel_phrase list</span>, exn)</span> Stdlib.result</span></code></dt><dd><p>Parse given string.</p><dl><dt>returns</dt><dd><p>a result with phrases or an error, along with the last parse location</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-port"><a href="#val-port" class="anchor"></a><code><span class="keyword">val</span> port : <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <span>var:string</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p><code>port ~var expr</code> ports the content of <code>expr</code>, typically a variable (which must have a logic type) into logic mode, into the new variable <code>var</code>.</p><dl><dt>parameter var</dt><dd><p>the name of the variable that will receive the logic-mode value</p></dd></dl><dl><dt>parameter quiet</dt><dd><p>if true, won't print the binding</p></dd></dl><dl><dt>parameter expr</dt><dd><p>a string containing an OCaml expression whose type is defined in logic mode. In general this expression can be a simple variable, or a more complicated computation.</p><p>Example:</p><pre><code class="ml">let a = print_endline &quot;coucou&quot;; 42 [@@program];;

Imandra.port ~var:&quot;logic_a&quot; &quot;a&quot;;;

verify (logic_a=42);;

Imandra.port ~var:&quot;logic_a_succ&quot; &quot;a+1&quot;;;

verify (logic_a_succ=43);;</code></pre></dd></dl></dd></dl><dl><dt class="spec value" id="val-eval_code_fragment"><a href="#val-eval_code_fragment" class="anchor"></a><code><span class="keyword">val</span> eval_code_fragment : <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> Imandra_surface.Code_fragment.t <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-undo"><a href="#val-undo" class="anchor"></a><code><span class="keyword">val</span> undo : int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>undo n</code> cancels the last <code>n</code> toplevel phrases entered by the user</p></dd></dl><dl><dt class="spec value" id="val-add_plugin"><a href="#val-add_plugin" class="anchor"></a><code><span class="keyword">val</span> add_plugin : Imandra_surface.Plugin.t <span>&#45;&gt;</span> unit</code></dt><dd><p>Add the given plugin and apply it to history retroactively. From now on all events will be processed by this plugin. It blocks until all code fragments have been executed.</p><p>It is simpler to call this as early as possible if one wants to use <code>#reset</code> or <code>#undo</code>.</p><p>See <code>Plugin</code> for more information.</p></dd></dl><dl><dt class="spec value" id="val-collect_plugin"><a href="#val-collect_plugin" class="anchor"></a><code><span class="keyword">val</span> collect_plugin : Imandra_surface.Plugin.t <span>&#45;&gt;</span> <span>Imandra_surface.Code_fragment.t list</span></code></dt><dd><p>Run the plugin on all events so far, but instead of executing its code fragments, just collect them</p></dd></dl><dl><dt class="spec value" id="val-add_plugin_pp"><a href="#val-add_plugin_pp" class="anchor"></a><code><span class="keyword">val</span> add_plugin_pp : unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_plugin_reflect"><a href="#val-add_plugin_reflect" class="anchor"></a><code><span class="keyword">val</span> add_plugin_reflect : unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_plugin_yojson"><a href="#val-add_plugin_yojson" class="anchor"></a><code><span class="keyword">val</span> add_plugin_yojson : unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_plugin_finite_type"><a href="#val-add_plugin_finite_type" class="anchor"></a><code><span class="keyword">val</span> add_plugin_finite_type : unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_plugin_gen_json"><a href="#val-add_plugin_gen_json" class="anchor"></a><code><span class="keyword">val</span> add_plugin_gen_json : <span>?&#8288;logic_deser:bool</span> <span>&#45;&gt;</span> <span>mod_name:string</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_plugin_rand"><a href="#val-add_plugin_rand" class="anchor"></a><code><span class="keyword">val</span> add_plugin_rand : <span>?&#8288;mod_name:string</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt></dl></section><section><header><h3 id="extension-points"><a href="#extension-points" class="anchor"></a>Extension Points</h3></header><div class="spec module" id="module-Custom_extension_point"><a href="#module-Custom_extension_point" class="anchor"></a><code><span class="keyword">module</span> Custom_extension_point = Imandra_syntax.Rewrite_parsetree.Custom_extension</code></div><dl><dt class="spec value" id="val-add_custom_extension_expr"><a href="#val-add_custom_extension_expr" class="anchor"></a><code><span class="keyword">val</span> add_custom_extension_expr : string <span>&#45;&gt;</span> <a href="index.html#module-Custom_extension_point">Custom_extension_point</a>.expr_tr <span>&#45;&gt;</span> unit</code></dt><dd><p>Define a custom extension point</p></dd></dl><dl><dt class="spec value" id="val-add_custom_extension_value_binding"><a href="#val-add_custom_extension_value_binding" class="anchor"></a><code><span class="keyword">val</span> add_custom_extension_value_binding : string <span>&#45;&gt;</span> <a href="index.html#module-Custom_extension_point">Custom_extension_point</a>.value_binding_tr <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-add_custom_extension_string_lit"><a href="#val-add_custom_extension_string_lit" class="anchor"></a><code><span class="keyword">val</span> add_custom_extension_string_lit : string <span>&#45;&gt;</span> <a href="index.html#module-Custom_extension_point">Custom_extension_point</a>.string_lit_tr <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-with_local_custom_extensions"><a href="#val-with_local_custom_extensions" class="anchor"></a><code><span class="keyword">val</span> with_local_custom_extensions : <span><span>(string * <a href="index.html#module-Custom_extension_point">Custom_extension_point</a>.tr)</span> list</span> <span>&#45;&gt;</span> <span>(unit <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl></section><section><header><h3 id="main-loop"><a href="#main-loop" class="anchor"></a>Main Loop</h3></header><dl><dt class="spec value" id="val-interactive_loop"><a href="#val-interactive_loop" class="anchor"></a><code><span class="keyword">val</span> interactive_loop : <span>?&#8288;init:bool</span> <span>&#45;&gt;</span> <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> <span>?&#8288;linenoise:bool</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Main loop for a toplevel that reads on stdin and prints on stdout.</p><dl><dt>parameter init</dt><dd><p>if true, calls <a href="index.html#val-do_init"><code>do_init</code></a> first</p></dd></dl><dl><dt>parameter linenoise</dt><dd><p>if true, use linenoise for interactive input</p></dd></dl><dl><dt>parameter syntax</dt><dd><p>syntax to use</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-process_file"><a href="#val-process_file" class="anchor"></a><code><span class="keyword">val</span> process_file : <span>?&#8288;init:bool</span> <span>&#45;&gt;</span> <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <span>Parsetree.toplevel_phrase list</span> * <span>Imandra_surface.Event.t list</span> * <span>Imandra_surface.Top_result.t list</span></code></dt><dd><p><code>process_file path</code> parses the file and returns its content and a list of events. This is useful for batch compilation.</p></dd></dl></section><section><header><h3 id="render-documents"><a href="#render-documents" class="anchor"></a>Render Documents</h3></header><dl><dt class="spec value" id="val-display"><a href="#val-display" class="anchor"></a><code><span class="keyword">val</span> display : Imandra_document.Document.t <span>&#45;&gt;</span> unit</code></dt><dd><p>Prints the document a way or another</p></dd></dl><section><header><h4 id="string--&gt;-term-and-expr-conversion"><a href="#string--&gt;-term-and-expr-conversion" class="anchor"></a>String -&gt; Term and Expr conversion</h4></header><dl><dt class="spec value" id="val-term_of_string"><a href="#val-term_of_string" class="anchor"></a><code><span class="keyword">val</span> term_of_string : string <span>&#45;&gt;</span> Imandra_surface.Term.t</code></dt><dt class="spec value" id="val-syn_term_of_string"><a href="#val-syn_term_of_string" class="anchor"></a><code><span class="keyword">val</span> syn_term_of_string : string <span>&#45;&gt;</span> Imandra_surface.Term.Syn.t</code></dt></dl></section></section><section><header><h3 id="module-system"><a href="#module-system" class="anchor"></a>Module System</h3></header><dl><dt class="spec value" id="val-import_file"><a href="#val-import_file" class="anchor"></a><code><span class="keyword">val</span> import_file : <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Import given module (and its dependencies, recursively) by its file name</p></dd></dl><dl><dt class="spec value" id="val-require_lib"><a href="#val-require_lib" class="anchor"></a><code><span class="keyword">val</span> require_lib : <span>?&#8288;meth:<span>[ `Mod_use <span>| `Import</span> <span>| `Use</span> ]</span></span> <span>&#45;&gt;</span> <span>?&#8288;syntax:Imandra_syntax.Syntax.t</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Require an ocamlfind library and its Imandra attachment, using either <code>import</code> or <code>mod_use</code> to load its content.</p></dd></dl><div class="spec module" id="module-Gist"><a href="#module-Gist" class="anchor"></a><code><span class="keyword">module</span> <a href="Gist/index.html">Gist</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec exception" id="exception-Init_fail"><a href="#exception-Init_fail" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">Init_fail</span></code></dt></dl></section></div></body></html>